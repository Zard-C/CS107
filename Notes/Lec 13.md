# Let 13 

主要内容





## 1. 小改动对编译和链接的影响

```cpp
#include <stdio.h> 
#include <stdlib.h> 
#include <assert.h> 



int main(int argc, char** argv)
{
    
    void* mem = malloc(400); 
    assert(mem!= NULL); 
    printf("Yay!\n");
    free(mem);
    return 0; 
}

```

```shell
gcc main.c 
```

![image-20220214200120343](Lec 13.assets/image-20220214200120343.png)

程序生成汇编代码，并由链接器进行重组。这个例子中只有一个.o文件，其他部分来自于编译器标准库或标准的.o代码，标准的编译器会提供printf，malloc, free, realloc, fprintf以及类似函数对应的.o代码进行链接。通常编译器会将一些必要的代码一个接着一个放置，生成一个更大的可执行文件。并且去掉那些没有用到的部分。但是一定会保留那些在执行过程中可能出现的函数。并且可执行程序在运行时应该能够跳转到程序的任意位置。

程序会通过编译，正常执行，打印出Yay！，并且作为副作用，程序会首先申请400字节的缓冲区空间，确保它申请成功了，然后打印消息，释放掉它并返回0.这意味着它会很快地打印出Yay，malloc和free函数可以成功的调用并且能够正常工作。

小的改动会对编译和链接产生怎样的影响？ 

### 1 注释掉<stdio.h> 

```c
//#include <stdio.h> 
#include <stdlib.h> 
#include <assert.h> 



int main(int argc, char** argv)
{
    
    void* mem = malloc(400); 
    assert(mem!= NULL); 
    printf("Yay!\n");
    free(mem);
    return 0; 
}
```

这样会产生编译错误吗？即使编译器看不到printf函数的原型。

答案是：对于部分编译器来说是正确的，会产生编译错误。

将这一行注释掉，那么预处理器生成的翻译单元中将不会有printf的声明。因此编译器检查printf函数是否被正确调用的时候，它会发现之前并没有看到这个函数的声明。这时多数的编译器会报错说:我没有见过这个函数原型，因此我没有办法调用那些没有见过原型的函数，所以我只能报错了！

但是例外的是，gcc就不会报错，gcc会在编译时刻分析源程序，看看哪一部分看起来像是函数调用，他会根据这个函数调用来推测函数的原型。

编译器看到这里只有一个字符串作为参数，然后会发出一个警告，因为没有见到函数原型，但是它并不会停下来，还会继续生成.o文件。只要最终的这个函数原型是这个的话，这个函数掉用就没有错误。只要你至少传入一个字符串，printf就没有语法错误。并且在这个调用中没有占位符。因此也不会出现运行时错误。

当gcc根据调用来推测一个函数原型的时候，默认地会将返回类型推测为int，碰巧printf的返回值的确是int类型。通常我们不会用到这个返回值，但是实际上这个返回值等于成功匹配的占位符的个数。对于这次调用来说会返回0，因为没有占位符。但是在这里我们并不关心返回值，而是关心返回类型。这个返回类型碰巧和gcc编译器推测的一致。

现在，如果在这个printf调用之后，还有一些printf调用的话，他们只能拥有一个参数，因为printf的函数原型是推测出来的，它与实际的函数原型还是稍微有区别的。

```c
int printf(const char *restrict format, ...);	//实际的函数原型
int printf(char*);					// 推测出来的函数原型
```

既然可以通过编译，那么生成的.o文件会是怎样的呢？

实际上完全没有变，这个.h只是包含结构的定义以及一些原型。对它来说不会产生任何的汇编代码，它的作用是告诉编译器一些规则，让编译器可以判定程序的哪些部分语法是正确的，哪些部分语法是错误的。不过当它推导这个函数原型时，编译器会在编译阶段发出一条警告来告诉程序员，但它还是会让`SP = SP -4`并且将字符串"Yay!/n"的地址拷贝到`M[SP]`中，并且依然会`CALL<printf>`并且希望通过RV来传递函数的返回值，虽然很可能会将这个值忽略掉，这样使用gcc可以得到这个.o文件。

会有一半的同学会认为在链接阶段，命令会终止，因为链接器并没有发现程序中包含printf的定义。每当你使用gcc创建可执行程序的时候，实际上在链接阶段会使用链接命令ld，让链接器来完成这个过程，链接器会根据编译过程中出现的警告来查找标准库，printf对应的代码就在标准库中，因此在链接阶段会被加进来。即使在链接之前，我们并没有看到过它的原型。因此#include并不能保证相应的函数实现在链接时可用，如果某个函数定义在标准库中，那么在链接时就可以被加进来。无论我们是否声明了函数原型。



### 注释掉#include <stdlib.h> 

```c
#include <stdio.h> 
//#include <stdlib.h> 
#include <assert.h> 



int main(int argc, char** argv)
{
    
    void* mem = malloc(400); 
    assert(mem!= NULL); 
    printf("Yay!\n");
    free(mem);
    return 0; 
}
```

那么现在就没有了malloc 和 free 的函数原型了，再次编译程序的话，在处理时遇到malloc调用，但是并不知道malloc究竟时什么。但是我们这里的写法看起来像是函数调用，因此编译器会将这个推测为一个函数，并且推测函数有一个int类型的参数，int类型的返回值。

```c
void *malloc(size_t size);	// 实际的函数原型
int malloc (int); 	// 推导出的函数原型
```

编译器并不会查看赋值语句来推测返回值的类型，因此它会对这一行报出两个警告：

1. 没有看到malloc的函数原型
2. 根据推测出的函数原型，这是对void* 类型的指针赋值了int类型

但是到了free这一行。编译器同样不知道它是什么，因为没有看到它的函数原型，于是编译器推导它的原型，并报出一条警告，然后指出它推测的free原型是什么，它假设free的参数是`void*`（因为传入的参数是`void*`类型），并且返回值是int，虽然并不是这样，但是我们并没有对返回值进行任何操作,因此这样推导没有问题。

```c
void free(void *ptr);	// 实际的函数原型
int free(void*);	// 编译器推导的原型
```



然后编译器继续分析下面的内容，生成的.o文件与之前的并没有任何的区别。（原因同上），只是它在这个过程中会报出3个警告信息：两条是因为没有看到函数原型，而一条是因为左值和右值的类型不兼容。

但是仍然会完成编译过程，然后在链接阶段，ld会忘掉这些警告，编译器并没有记录说这里没有包含某个头文件，也不会记录在编译时刻存在某些警告，只是运行的话会有一点危险，但是生成的.o文件与你写的这段代码语义是完全一致的。

所以当链接并且运行这个程序的时候，这个程序并不会产生什么问题。

Q&A 为何注释掉了还会得到正确的a.out并执行

问题在于编译器并不能理解为什么会正确执行，其实头文件做的全部事情就是告诉编译器有哪些函数原型，但在.h文件中并没有说明这些函数的代码在哪里。链接阶段则负责去标准库中寻找这些代码，而malloc, free, 和 printf正是在标准库中，这就好像由于#include 的存在，让.o文件有了一些钩子（这些钩子用来联系标准库代码），只要这些函数在标准库中出现，无论在编译时有无警告，生成的可执行文件中都会包含这些，因此在链接的时候就可以用到标准库的代码，并且将调用到的函数的代码加进来，因此会在.o文件中出现相应标号的函数，生成可执行文件.o

而且，在这个例子中没有自定义的printf和free

如果将上面的两行都注释掉，会产生4条警告信息，但是依然会生成.o文件，并且会链接生成a.out, 在运行的时候

### 注释掉<assert.h> 

```c
#include <stdio.h> 
#include <stdlib.h> 
//#include <assert.h> 



int main(int argc, char** argv)
{
    
    void* mem = malloc(400); 
    assert(mem!= NULL); 
    printf("Yay!\n");
    free(mem);
    return 0; 
}
```

如果在代码中没有提及assert这个符号在编译单元中是什么的话，当编译器分析到这一行的时候会说：我不知道assert是什么，编译器会猜测它是一个函数调用, 因此在.o文件中会出现`CALL <assert>`这样一条指令，整体通过编译，但是在链接的时候会失败。

失败的原因是，虽然标准库中有很多的函数实现，如printf, malloc, free 因为它们都是真正的函数，但是在标准库中却没有assert，因为assert是一个宏，不是函数。

所以正是这样的原因才需要原型：函数原型的存在是为了让调用者和被调用者关于savedPC上面的活动记录布局达成一致（也就是让函数的调用参数符合参数类型规定），原型其实只涉及函数参数，参数在活动记录中位于savedPC之上，而在savedPC之下的那些内容，是被调用者来负责的。

当我们调用printf，并跳转到printf函数对应的代码时，我们需要确保活动记录中上半部分的信息格式对于调用者和被调用者而言时一致的。因为调用printf的时候，我将一个字符串常量的地址作为参数，然后让被调用者接管并且继续执行。

printf会接管执行并且说：根据函数原型我认为在savedPC的上方是一个字符串，因为这个函数中我就是这么规定的。如果不是字符串，那恐怕就要出问题了。如果是字符串，那我就将它打印出来。

```c
int main()
{
    int num = 65; 
    int length = strlen(&(char*)&num,, num); 	//	诡异的方式进行调用
    printf("length = %d \n", length); 
    return 0; 
}
```

编译器看到这一行会发出警告，因为没有函数原型,它会将参数推导为(char* ,int)，返回值为int ,因为对所有未知的原型。

```c
size_t strlen(const char *str);	// 真实的函数原型
int strlen(char*, int);	//	 推导出来的函数原型
```

如果这个代码编译的话，编译器只会报出一条警告。不过这个函数`strlen`调用出错了，标准库的strlen其实只有一个字符串参数