# Lec 14 





## Channeling

```c
void foo() 
{
    int array[4]; 
    int i ; 
    for(i = 0; i <= 4; ++i)
    {
        array[i] -= 4; 
    }
}
```

陷入死循环的原因：缓冲区溢出导致修改了savedPC的值，将savedPC值-4，将本该指向`CALL<foo>`下一条语句的saved PC指向了`CALL <foo>`	当函数返回时，又执行了`CALL<foo>`.实际上是一种递归。

在solaris的内存模型比我们讲到的要复杂一些。它们并不是让savedPC与这些变量直接相邻，不过也不会差太多。

```c
int main(int argc, char**argv)
{
    DeclareAndInitArray(); 
    PrintArray(); 
}


// 短小却很优美的代码，但是对作用域外没有任何贡献
// 404 字节的活动记录
void DeclareAndInitArray()
{
    int arr[100]; 
    int i; 
    for(i = 0; i < 100; i++)
    {
        array[i] = i; 
    }
}

// 
void printArray()
{
    int array[100]; 
    int i;
    for(int i = 0; i < 100; ++i)
    {
        printf("%d \n", array[i]); 
    }
 
}
```

没有全局变量的参与，两个函数之间如何交互信息呢？虽然我们不喜欢全局变量，但它依旧是在函数调用间交换信息的一个合法途径。但是这里并不支持全局变量。程序也不认为它需要全局变量。

结果是可以正常输出DeclareAndInitArray() 初始化的数组。

DeclareAndInitArray() 有404个字节的活动记录，array数组占据了上面的400字节，变量i占据了最下面的4个字节。经过系列操作之后，函数返回。然后调用了另外一个函数printArray(), 它的活动记录与之前调用的函数的活动记录完全一样。这个函数的活动记录同样包含了404字节。 并且打印出之前的函数操作之后留在内存中的数据的值。等同从结构相同的活动记录中访问同一块内存。

因为当上一个函数返回的时候，并不会对使用过的内存进行reset，清空这里的位模式。因为执行这个操作时要花费时间的。

这在以前是一种高级的技巧，但是现在我们的程序不一定是顺序执行的。

11year ago 对于每个硬件中断，你都要执行一小段代码，但是中断的小周期中，能做的事情太少了。因此必须在下一个周期中再做一些事情。事实上，对于中断里面要做的事情并没有那么多的时间来完成相应的处理逻辑。因此很多时候你需要提前准备好这些信息。每次都是直接使用它们，而不是再次去生成它们。

可以认为是奇怪且讨巧的全局变量。可以提前将参数写到内存中位以后的调用做准备。

有经验的C++程序员会利用内存布局来使用这种技巧。
