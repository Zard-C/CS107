# Lec 2

## C 语言指针的-底层特性 

## 基本类型的底层存储机制

```c
bool
char 			1 byte
short			2 bytes
int 			2 -4 bytes
long;			4 bytes
float;		4 bytes
double;		8 bytes 
```

### binary digit -> bit

​	 2 different values 

### char

1 bytes - > 8 bits -> 256 == 2^8

'A' -> `0100 0001` -> 2^6 + 2^0

### short 

2^16 values 

`0111 1111 1111 1111`-> 2^15 -1

第一位作为符号位

### 负数的二进制表示形式：补码

`0000 0000 0000 0111` - >7 

`1111 1111 1111 1001`-> -7

 positive 7 plus negative 7 在内存中可以优雅地全变成0，这样计算机硬件可以更方便的存储

与得到全0相比，得到全1更容易，然后再加上1，就可以得到全0。

2^15 -1 ~ -2^16

### 截断

```c
char ch = 'A'; 
short s = ch; 	/* 按位复制： copy the bit patten  */
cout << s <<endl;
// 65;
```

```c
short s = 67;
char ch = s;
cout << s <<endl; 
// C 
```

截断：没有空间放置时，简单地将高位进行截断。

```c
short s = 2^10 + 2^3 + 2^0;
int i = s; 
```

```c
int i = 2^23 + 2^21 + 2^15 + 7; 
short s = i; 
// s -> 2^15 + 2^7 进行了整数截断
```

类型转换时：符号位的变成代表数量位是未定义的行为。

### 符号扩展

```c
short s = -1; /* 1111 1111 1111 1111 */
int i = s;		/* 1111 1111 1111 1111 1111 1111 1111 1111  */ 
// 仍然使用位模式拷贝 使用符号位作为原始数字，进行符号扩展
```

### 浮点数的表示方法

​	用2^-n 去逼近想得到的值： 精度

| signed bit | magnitude only | precision |
| ---------- | -------------- | --------- |
| 1 bytes    | 8 bits         | .xxxxxx   |
| (-1)^s     | exp            | 1.xxxxx   |

$$
(-1)^s*(1.xxxxx)*2^(exp - 127）
$$

7.0 = 3.5*2^1 = 1.75 * 2^2, 1.75 	落在1.xxxx范围内。

### 整数与浮点数相互转换

```c
int i = 5;
float f = i; 5->5.0 -> 1.25*2^2
cout << f <<endl; // 5 
```

​	相互转换时会计算转换后的位模式是什么，然后创建变量进行赋值操作。

```c
int i = 37;
float f = *(float *)&i; 
// 一个非常小的数字
```

`0000 0000 0001 0101` -> 强制转换成了float* 类型，位模式不会改变，并按照float类型对位模式进行解释。

### 强制类型转换

```c
float f = 7.0;
short *s = *(short *)&f; 
```

- 大端字节序

- 小端字节序

  

















​	